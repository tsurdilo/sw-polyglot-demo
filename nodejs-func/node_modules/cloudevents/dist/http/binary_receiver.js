"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BinaryHTTPReceiver = void 0;
const __1 = require("../..");
const v1_1 = require("../../event/v1");
const v03_1 = require("../../event/v03");
const headers_1 = require("./headers");
const receiver_1 = require("./v1/receiver");
const receiver_2 = require("./v03/receiver");
const validation_1 = require("../../event/validation");
const parsers_1 = require("../parsers");
const parserByContentType = {
    "application/json": new parsers_1.JSONParser(),
    "application/octet-stream": new parsers_1.PassThroughParser()
};
const parsersByEncoding = {
    base64: {
        "application/json": new parsers_1.JSONParser(new parsers_1.Base64Parser()),
        "application/octet-stream": new parsers_1.PassThroughParser()
    }
};
/**
 * A class that receives binary CloudEvents over HTTP. This class can be used
 * if you know that all incoming events will be using binary transport. If
 * events can come as either binary or structured, use {HTTPReceiver}.
 */
class BinaryHTTPReceiver {
    constructor(version = __1.Version.V1) {
        this.version = version;
    }
    /**
     * Parses an incoming HTTP request, converting it to a {CloudEvent}
     * instance if it conforms to the Cloud Event specification for this receiver.
     *
     * @param {Object|string} payload the HTTP request body
     * @param {Object} headers the HTTP request headers
     * @param {Version} version the spec version of the incoming event
     * @returns {CloudEvent} an instance of CloudEvent representing the incoming request
     * @throws {ValidationError} of the event does not conform to the spec
     */
    parse(payload, headers) {
        payload = validation_1.isString(payload) && validation_1.isBase64(payload)
            ? Buffer.from(payload, "base64").toString()
            : payload;
        // Clone and low case all headers names
        const sanitizedHeaders = headers_1.validate(headers);
        const eventObj = {};
        const parserMap = this.version === __1.Version.V1 ? receiver_1.binaryParsers : receiver_2.binaryParsers;
        Array.from(Object.keys(parserMap))
            .filter((header) => sanitizedHeaders[header])
            .forEach((header) => {
            const parser = parserMap[header].parser;
            eventObj[parserMap[header].name] = parser(sanitizedHeaders[header]);
            delete sanitizedHeaders[header];
        });
        // Parses the payload
        let parser;
        if (eventObj.dataContentEncoding) {
            parser = parsersByEncoding[eventObj.dataContentEncoding][eventObj.dataContentType];
        }
        else {
            parser = parserByContentType[eventObj.dataContentType];
        }
        const parsedPayload = parser.parse(payload);
        const cloudevent = new __1.CloudEvent(Object.assign(Object.assign({}, eventObj), { data: parsedPayload }));
        // Every unprocessed header can be an extension
        Array.from(Object.keys(sanitizedHeaders))
            .filter((value) => value.startsWith("ce-"))
            .map((extension) => extension.substring("ce-".length))
            // @ts-ignore we know that extensions is never undefined
            .forEach((extension) => cloudevent.extensions[extension] = sanitizedHeaders[`ce-${extension}`]);
        // Validates the event
        this.version === __1.Version.V1 ? v1_1.validate(cloudevent) : v03_1.validate(cloudevent);
        return cloudevent;
    }
}
exports.BinaryHTTPReceiver = BinaryHTTPReceiver;
