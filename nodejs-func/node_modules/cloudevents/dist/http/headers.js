"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sanitize = exports.validate = exports.requiredHeaders = exports.allowedContentTypes = void 0;
const __1 = require("../..");
;
exports.allowedContentTypes = ["application/json", "application/octet-stream"];
exports.requiredHeaders = ["ce-id", "ce-source", "ce-type", "ce-specversion"];
function validate(headers) {
    const sanitizedHeaders = sanitize(headers);
    // if content-type exists, be sure it's an allowed type
    const contentTypeHeader = sanitizedHeaders["content-type"];
    const noContentType = !exports.allowedContentTypes.includes(contentTypeHeader);
    if (contentTypeHeader && noContentType) {
        throw new __1.ValidationError("invalid content type", [sanitizedHeaders["content-type"]]);
    }
    exports.requiredHeaders
        .filter((required) => !sanitizedHeaders[required])
        .forEach((required) => {
        throw new __1.ValidationError(`header '${required}' not found`);
    });
    if (!sanitizedHeaders["content-type"]) {
        sanitizedHeaders["content-type"] = "application/json";
    }
    return sanitizedHeaders;
}
exports.validate = validate;
function sanitize(headers) {
    validate(headers);
    const sanitized = {};
    Array.from(Object.keys(headers))
        .filter((header) => Object.hasOwnProperty.call(headers, header))
        .forEach((header) => sanitized[header.toLowerCase()] = headers[header]);
    sanitized["content-type"] = sanitizeContentType(sanitized["content-type"]);
    return sanitized;
}
exports.sanitize = sanitize;
function sanitizeContentType(contentType) {
    if (contentType) {
        return Array.of(contentType)
            .map((c) => c.split(";"))
            .map((c) => c.shift())
            .shift();
    }
    return contentType;
}
