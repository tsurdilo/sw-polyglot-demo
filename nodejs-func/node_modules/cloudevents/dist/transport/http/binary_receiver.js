"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BinaryHTTPReceiver = void 0;
const __1 = require("../..");
const spec_1 = require("../../event/spec");
const headers_1 = require("./headers");
const versions_1 = require("./versions");
const parsers_1 = require("../../parsers");
const validation_1 = require("../../event/validation");
const constants_1 = __importDefault(require("../../constants"));
/**
 * A class that receives binary CloudEvents over HTTP. This class can be used
 * if you know that all incoming events will be using binary transport. If
 * events can come as either binary or structured, use {HTTPReceiver}.
 */
class BinaryHTTPReceiver {
    constructor(version = "1.0" /* V1 */) {
        this.version = version;
    }
    /**
     * Parses an incoming HTTP request, converting it to a {CloudEvent}
     * instance if it conforms to the Cloud Event specification for this receiver.
     *
     * @param {Object|string} payload the HTTP request body
     * @param {Object} headers the HTTP request headers
     * @param {Version} version the spec version of the incoming event
     * @returns {CloudEvent} an instance of CloudEvent representing the incoming request
     * @throws {ValidationError} of the event does not conform to the spec
     */
    parse(payload, headers) {
        if (!headers)
            throw new validation_1.ValidationError("headers is null or undefined");
        if (payload) {
            validation_1.isStringOrObjectOrThrow(payload, new validation_1.ValidationError("payload must be an object or a string"));
        }
        if (headers[constants_1.default.CE_HEADERS.SPEC_VERSION] &&
            headers[constants_1.default.CE_HEADERS.SPEC_VERSION] !== "0.3" /* V03 */ &&
            headers[constants_1.default.CE_HEADERS.SPEC_VERSION] !== "1.0" /* V1 */) {
            throw new validation_1.ValidationError(`invalid spec version ${headers[constants_1.default.CE_HEADERS.SPEC_VERSION]}`);
        }
        payload = validation_1.isString(payload) && validation_1.isBase64(payload) ? Buffer.from(payload, "base64").toString() : payload;
        // Clone and low case all headers names
        const sanitizedHeaders = headers_1.validate(headers);
        const eventObj = {};
        const parserMap = this.version === "1.0" /* V1 */ ? versions_1.v1binaryParsers : versions_1.v03binaryParsers;
        for (const header in parserMap) {
            if (sanitizedHeaders[header]) {
                const mappedParser = parserMap[header];
                eventObj[mappedParser.name] = mappedParser.parser.parse(sanitizedHeaders[header]);
                delete sanitizedHeaders[header];
            }
        }
        let parsedPayload;
        if (payload) {
            const parser = parsers_1.parserByContentType[eventObj.datacontenttype];
            if (!parser) {
                throw new validation_1.ValidationError(`no parser found for content type ${eventObj.datacontenttype}`);
            }
            parsedPayload = parser.parse(payload);
        }
        // Every unprocessed header can be an extension
        for (const header in sanitizedHeaders) {
            if (header.startsWith(constants_1.default.EXTENSIONS_PREFIX)) {
                eventObj[header.substring(constants_1.default.EXTENSIONS_PREFIX.length)] = headers[header];
            }
        }
        // At this point, if the datacontenttype is application/json and the datacontentencoding is base64
        // then the data has already been decoded as a string, then parsed as JSON. We don't need to have
        // the datacontentencoding property set - in fact, it's incorrect to do so.
        if (eventObj.datacontenttype === constants_1.default.MIME_JSON &&
            eventObj.datacontentencoding === constants_1.default.ENCODING_BASE64) {
            delete eventObj.datacontentencoding;
        }
        const cloudevent = new __1.CloudEvent(Object.assign(Object.assign({}, eventObj), { data: parsedPayload }));
        spec_1.validateCloudEvent(cloudevent);
        return cloudevent;
    }
}
exports.BinaryHTTPReceiver = BinaryHTTPReceiver;
